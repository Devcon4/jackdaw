using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Jackdaw.SourceGenerator;

[Generator]
public class JackdawGenerator : IIncrementalGenerator
{
  public void Initialize(IncrementalGeneratorInitializationContext context)
  {
    var handlerClasses = context.SyntaxProvider
        .CreateSyntaxProvider(
            predicate: static (s, _) => s is ClassDeclarationSyntax c && c.BaseList != null,
            transform: static (ctx, _) => GetHandlerInfo(ctx))
        .Where(static m => m is not null);

    context.RegisterSourceOutput(handlerClasses.Collect(), GenerateDispatcher);
  }
  private static HandlerInfo? GetHandlerInfo(GeneratorSyntaxContext context)
  {
    var classDeclaration = (ClassDeclarationSyntax)context.Node;
    var symbol = context.SemanticModel.GetDeclaredSymbol(classDeclaration);

    if (symbol is not INamedTypeSymbol classSymbol)
      return null;

    var handlerInterface = classSymbol.AllInterfaces
        .FirstOrDefault(i =>
            i.IsGenericType &&
            i.ConstructedFrom.ToDisplayString() == "Jackdaw.Interfaces.IHandler<TRequest, TResponse>");

    if (handlerInterface is null)
      return null;

    var requestType = handlerInterface.TypeArguments[0];
    var responseType = handlerInterface.TypeArguments[1];

    // Look for [JackdawQueue("QueueName")] attribute
    var queueAttribute = classSymbol.GetAttributes()
        .FirstOrDefault(a => a.AttributeClass?.Name == "JackdawQueueAttribute");

    var queueName = queueAttribute?.ConstructorArguments.FirstOrDefault().Value?.ToString()
                    ?? "Default"; // Use "Default" if no attribute

    return new HandlerInfo(
        classSymbol.ToDisplayString(),
        requestType.ToDisplayString(),
        responseType.ToDisplayString(),
        queueName);
  }

  private record HandlerInfo(
      string HandlerType,
      string RequestType,
      string ResponseType,
      string QueueName);

  private void GenerateDispatcher(SourceProductionContext context, ImmutableArray<HandlerInfo?> handlers)
  {
    var validHandlers = handlers.Where(h => h is not null).Cast<HandlerInfo>().ToList();
    var handlersByQueue = validHandlers.GroupBy(h => h.QueueName).ToList();

    var handlerComments = string.Join("\n", validHandlers.Select(h =>
      $"// Handler: {h.HandlerType} -> Queue: {h.QueueName}"));

    var code = $$"""
      #nullable enable
      // <auto-generated/>
      // Found {{validHandlers.Count}} handler(s) across {{handlersByQueue.Count}} queue(s)
      {{handlerComments}}

      using System;
      using System.Threading;
      using System.Threading.Tasks;
      using Microsoft.Extensions.DependencyInjection;
      using Microsoft.Extensions.Hosting;
      using Jackdaw.Interfaces;

      namespace Jackdaw.Core;

      {{GenerateDispatcherClass(validHandlers)}}

      {{GenerateRouterClass(validHandlers)}}

      {{GenerateServiceExtensions(validHandlers, handlersByQueue)}}
      """;

    context.AddSource("HandlerDispatcher.g.cs", code);
  }
  private string GenerateDispatcherClass(List<HandlerInfo> handlers)
  {
    if (handlers.Count == 0)
    {
      return """
            file sealed class GeneratedHandlerDispatcher : IHandlerDispatcher
            {
                public async Task DispatchAsync(IRequestMetadata metadata, IServiceProvider serviceProvider, CancellationToken cancellationToken)
                {
                    throw new InvalidOperationException("No handlers registered.");
                }
            }
            """;
    }

    var getQueueName = (HandlerInfo handler) =>
    $$"""
    var queueName = {{(handler.QueueName is "Default" ? "serviceProvider.GetRequiredService<DefaultQueueName>().ActualQueueName" : $"\"{handler.QueueName}\"")}};
    """;


    var handlerCases = string.Join("\n", handlers.Select(handler =>
    {
      var hash = $"m{System.Math.Abs(handler.ResponseType.GetHashCode())}";
      return $$"""
                    case RequestMetadata<{{handler.ResponseType}}> {{hash}}:
                    {
                        {{getQueueName(handler)}}
                        var middlewares = serviceProvider.GetKeyedServices<IPipelineBehavior>(queueName);
                        var handler = serviceProvider.GetRequiredService<IHandler<{{handler.RequestType}}, {{handler.ResponseType}}>>();
                        Func<Task<{{handler.ResponseType}}>> pipeline = async () => 
                            await handler.Handle(({{handler.RequestType}}){{hash}}.Request, cancellationToken);
                        
                        foreach (var middleware in middlewares.Reverse())
                        {
                            var currentPipeline = pipeline;
                            pipeline = async () => await middleware.Handle<{{handler.RequestType}}, {{handler.ResponseType}}>(
                                ({{handler.RequestType}}){{hash}}.Request,
                                currentPipeline,
                                cancellationToken);
                        }
                        
                        try
                        {
                            var response = await pipeline();
                            {{hash}}.CompletionSource.SetResult(response);
                        }
                        catch (Exception ex)
                        {
                            {{hash}}.CompletionSource.SetException(ex);
                        }
                        break;
                    }
        """;
    }));

    return $$"""
        file sealed class GeneratedHandlerDispatcher : IHandlerDispatcher
        {
            public async Task DispatchAsync(IRequestMetadata metadata, IServiceProvider serviceProvider, CancellationToken cancellationToken)
            {
                switch (metadata)
                {
        {{handlerCases}}
                    default:
                        throw new InvalidOperationException($"No handler registered for {metadata.GetType().Name}");
                }
            }
        }
        """;
  }
  private string GenerateRouterClass(List<HandlerInfo> handlers)
  {
    if (handlers.Count == 0)
    {
      return """
        file sealed class GeneratedQueueRouter : IQueueRouter
        {
            private readonly IServiceProvider _serviceProvider;

            public GeneratedQueueRouter(IServiceProvider serviceProvider)
            {
                _serviceProvider = serviceProvider;
            }

            public IMessageQueue GetQueue<TRequest, TResponse>(TRequest request) where TResponse : IResponse where TRequest : IRequest<TResponse>
            {
                throw new InvalidOperationException("No handlers registered.");
            }
        }
        """;
    }

    var requestToQueue = handlers
      .GroupBy(h => h.RequestType)
      .ToDictionary(g => g.Key, g => g.First().QueueName);

    var switchCases = string.Join("\n", requestToQueue.Select(kvp =>
      $$"""            "{{kvp.Key}}" => _serviceProvider.GetRequiredKeyedService<IMessageQueue>("{{kvp.Value}}"),"""));

    return $$"""
      file sealed class GeneratedQueueRouter : IQueueRouter
      {
          private readonly IServiceProvider _serviceProvider;

          public GeneratedQueueRouter(IServiceProvider serviceProvider)
          {
              _serviceProvider = serviceProvider;
          }

          public IMessageQueue GetQueue<TRequest, TResponse>(TRequest request) where TResponse : IResponse where TRequest : IRequest<TResponse>
          {
              var requestType = request.GetType();
              return requestType.FullName switch
              {
      {{switchCases}}
                  _ => throw new InvalidOperationException(
                      $"No queue mapping found for request type {requestType.Name}. " +
                      $"Ensure the handler for this request is decorated with [JackdawQueue] attribute or register a default queue.")
              };
          }
      }
      """;
  }
  private string GenerateServiceExtensions(
      List<HandlerInfo> handlers,
      List<IGrouping<string, HandlerInfo>> handlersByQueue)
  {
    var handlerRegistrations = string.Join("\n", handlers.Select(handler =>
      $$"""        services.AddScoped<IHandler<{{handler.RequestType}}, {{handler.ResponseType}}>, {{handler.HandlerType}}>();"""));

    var runnerRegistrations = string.Join("\n\n", handlersByQueue.Select(queueGroup =>
    {
      var queueName = queueGroup.Key;
      return $$"""
              // MediatorRunner for '{{queueName}}' queue
              services.AddSingleton<IHostedService>(sp => 
                  new MediatorRunner(
                      "{{queueName}}",
                      sp,
                      sp.GetRequiredService<IHandlerDispatcher>()));
      """;
    }));

    return $$"""
      public static partial class ServiceCollectionExtensions
      {
          public static IServiceCollection AddJackdaw(this IServiceCollection services, Action<JackdawBuilder>? configure = null)
          {
              var builder = new JackdawBuilder(services);
              configure?.Invoke(builder);
              var isValid = builder.Initialize();
              if (!isValid)
              {
                  throw new InvalidOperationException("Invalid Jackdaw configuration.");
              }

      {{handlerRegistrations}}
              services.AddSingleton<IHandlerDispatcher, GeneratedHandlerDispatcher>();
              services.AddSingleton<IQueueRouter, GeneratedQueueRouter>();
              services.AddSingleton<IMediator, Mediator>();

      {{runnerRegistrations}}
              return services;
          }
      }
      """;
  }
}