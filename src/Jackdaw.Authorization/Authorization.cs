using Jackdaw.Core;
using Jackdaw.Interfaces;
using Jackdaw.Queues.InMemory;

namespace Jackdaw.Authorization;

public record AuthorizationResult(bool IsAuthorized, string? FailureReason = null) : IResponse
{
  public bool Success => IsAuthorized;
}

public interface IRequirement : IRequest<AuthorizationResult> { }

public interface IAuthorizer<TRequest>
{
  IEnumerable<IRequirement> Requirements { get; }
  void BuildPolicy(TRequest instance);
}

public static class JackdawAuthorizationExtensions
{
  public static JackdawBuilder AddAuthorization(this JackdawBuilder builder)
  {
    if (builder.GetQueueNames().Contains(AuthorizationOptions.InternalQueueName))
    {
      builder.AddValidation(b => (false, new InvalidOperationException($"The queue name '{AuthorizationOptions.InternalQueueName}' is reserved for authorization purposes and cannot be used.")));
    }
    builder.AddQueue(AuthorizationOptions.InternalQueueName).UseInMemory();
    return builder;
  }

  public static QueueBuilder UseAuthorization(this QueueBuilder builder, AuthorizationOptions? options = null)
  {
    builder.UseMiddleware<AuthorizationMiddleware>();
    return builder;
  }
}

public record AuthorizationOptions()
{
  public const string InternalQueueName = "__AuthorizationQueue";
};

public abstract class Authorizer<TRequest> : IAuthorizer<TRequest>
{
  private readonly HashSet<IRequirement> _requirements = new();
  public IEnumerable<IRequirement> Requirements => _requirements;
  public void UseRequirement(IRequirement requirement)
  {
    _requirements.Add(requirement);
  }
  public abstract void BuildPolicy(TRequest instance);
}

[JackdawQueue(AuthorizationOptions.InternalQueueName)]
public interface IRequirementHandler<TRequirement> : IHandler<TRequirement, AuthorizationResult>
  where TRequirement : IRequirement
{ }

public interface IRequirementRouter
{
  IEnumerable<IRequirement> GetRequirements<TRequest, TResponse>(TRequest request) where TResponse : IResponse where TRequest : IRequest<TResponse>;
}
public class GeneratedRequirementRouter : IRequirementRouter
{
  public IEnumerable<IRequirement> GetRequirements<TRequest, TResponse>(TRequest request) where TResponse : IResponse where TRequest : IRequest<TResponse>
  {
    // Implementation generated by source generator
    return [];
  }
}

public class AuthorizationMiddleware(IRequirementRouter router, IMediator mediator) : IPipelineBehavior
{
  public async Task<TResponse> Handle<TRequest, TResponse>(TRequest request, Func<Task<TResponse>> next, CancellationToken cancellationToken)
    where TRequest : IRequest<TResponse>
    where TResponse : IResponse
  {
    var requirements = router.GetRequirements<TRequest, TResponse>(request);

    foreach (var requirement in requirements)
    {
      var result = await mediator.Send(requirement, cancellationToken);
      if (!result.IsAuthorized)
      {
        throw new JackdawAuthorizationException(result.FailureReason ?? "Unknown", requirement);
      }
    }

    return await next();
  }
}

public class JackdawAuthorizationException(string failureReason, IRequirement requirement) : UnauthorizedAccessException($"Authorization failed for requirement {requirement.GetType().Name}: {failureReason}")
{
  public IRequirement Requirement => requirement;
}