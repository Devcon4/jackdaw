using Jackdaw.Core;
using Jackdaw.Interfaces;
using Jackdaw.Queues.InMemory;
using Microsoft.Extensions.Logging;

namespace Jackdaw.Authorization;

public record AuthorizationResult(bool IsAuthorized, string? FailureReason = null) : IResponse
{
  public bool Success => IsAuthorized;
}

public interface IAuthorizerRequirement : IRequest<AuthorizationResult> { }

public interface IJackdawAuthorizer<TRequest>
{
  IEnumerable<IAuthorizerRequirement> Requirements { get; }
  void BuildPolicy(TRequest instance);
}

public static class JackdawAuthorizationExtensions
{
  public static JackdawBuilder AddAuthorization(this JackdawBuilder builder)
  {
    // queue AuthorizationOptions.InternalQueueName is reserved for authorization purposes and should not be used by other queues.
    if (builder.GetQueueNames().Contains(AuthorizationOptions.InternalQueueName))
    {
      builder.AddValidation(b => (false, new InvalidOperationException($"The queue name '{AuthorizationOptions.InternalQueueName}' is reserved for authorization purposes and cannot be used.")));
    }
    builder.AddQueue(AuthorizationOptions.InternalQueueName).UseInMemory();
    return builder;
  }

  public static QueueBuilder UseAuthorization(this QueueBuilder builder, AuthorizationOptions? options = null)
  {
    builder.UseMiddleware<AuthorizationMiddleware>();
    return builder;
  }
}
public record AuthorizationOptions()
{
  public const string InternalQueueName = "__AuthorizationQueue";
};

public abstract class JackdawAuthorizer<TRequest> : IJackdawAuthorizer<TRequest>
{
  private readonly HashSet<IAuthorizerRequirement> _requirements = new();
  public IEnumerable<IAuthorizerRequirement> Requirements => _requirements;
  public void UseRequirement(IAuthorizerRequirement requirement)
  {
    _requirements.Add(requirement);
  }
  public abstract void BuildPolicy(TRequest instance);
}

[JackdawQueue(AuthorizationOptions.InternalQueueName)]
public interface IRequirementHandler<TRequirement> : IHandler<TRequirement, AuthorizationResult>
  where TRequirement : IAuthorizerRequirement
{
}

public record SampleRequirement(string PermissionName) : IAuthorizerRequirement;
public class SampleRequirementHandler : IRequirementHandler<SampleRequirement>
{
  public Task<AuthorizationResult> Handle(SampleRequirement request, CancellationToken cancellationToken)
  {
    return Task.FromResult(new AuthorizationResult(request.PermissionName == "Allow"));
  }
}

// Generated through source generator; Maps routes to list of requirements
public interface IRequirementRouter
{
  IEnumerable<IAuthorizerRequirement> GetRequirements<TRequest, TResponse>(TRequest request) where TResponse : IResponse where TRequest : IRequest<TResponse>;
}
public class GeneratedRequirementRouter : IRequirementRouter
{
  public IEnumerable<IAuthorizerRequirement> GetRequirements<TRequest, TResponse>(TRequest request) where TResponse : IResponse where TRequest : IRequest<TResponse>
  {
    // Implementation generated by source generator
    return [];
  }
}

public class AuthorizationMiddleware(IRequirementRouter router, IMediator mediator) : IPipelineBehavior
{
  public async Task<TResponse> Handle<TRequest, TResponse>(TRequest request, Func<Task<TResponse>> next, CancellationToken cancellationToken)
    where TRequest : IRequest<TResponse>
    where TResponse : IResponse
  {
    var requirements = router.GetRequirements<TRequest, TResponse>(request);

    foreach (var requirement in requirements)
    {
      var result = await mediator.Send(requirement, cancellationToken);
      if (!result.IsAuthorized)
      {
        throw new JackdawAuthorizationException(result.FailureReason ?? "Unknown", requirement);
      }
    }

    return await next();
  }
}

public class JackdawAuthorizationException(string failureReason, IAuthorizerRequirement requirement) : UnauthorizedAccessException($"Authorization failed for requirement {requirement.GetType().Name}: {failureReason}")
{
  public IAuthorizerRequirement Requirement => requirement;
}